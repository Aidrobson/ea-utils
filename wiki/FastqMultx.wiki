#summary One-sentence summary of this page.

= Introduction =

The ides behind this is to reduce the amount of "piping" going on in a pipeline.   A lot of time, disk space and nail-chewing is spent keeping files in sync, figuring out what barcodes are on what samples, etc.  The goal of this program is to make it easier to demultiplex possibly paired-end sequences.

= Usage =

{{{
Usage: fastq-multx [-g|-l] <barcode.fil> <read1.fq> -o r1.%.fq [read2.fq -o r2.%.fq] ...

Output files must contain a '%' sign which is replaced with the barcode id in the barcodes file.

If the first file output is 'n/a' or '/dev/null', it is not written.

Basic barcode files look like this:

<id1> <sequence1>
<id2> <sequence2> ...

The default is to guess the -bol or -eol based on some quick stats.

If -g is used, and the supplied file has reads of average length < 10, then it is assumed to
be an "index read", and frequently occuring sequences are calculated.

If -l is used then all barcodes in that file are tried, and the *group* with the most matches is chosen.

Grouped barcode files looks like this:

<id1> <sequence1> <protocol1>
<id2> <sequence2> <protocol1>
<id2> <sequence2> <protocol2>...

Options:

-o FIL1 [FIL2]  Output files (one per input, required)
-g FIL          Determine barcodes from indexed read FIL
-l FIL          Determine barcodes from any read, using FIL as a master list
-b              Force beginning of line
-e              Force end of line
-x              Don't trim barcodes before writing
-n              Don't execute, just print likely barcode list
-v C            Verify that mated id's match up to character C ('/' for illumina)
-m N            Allow up to N mismatches, as long as they are unique
}}}